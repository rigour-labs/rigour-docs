# Rigour Documentation

No Bullshit Code Review for AI Agents

## GETTING-STARTED

# Getting Started

Rigour is designed to be set up in under 60 seconds. You can run it directly with `npx` (no install required) or install it globally.

---

## 1. Installation

### The Zero-Install Way (Recommended)
You don't need to install anything. Just run:
```bash
npx @rigour-labs/cli --help
```

### Global Installation
```bash
npm install -g @rigour-labs/cli
```

---

## 2. Project Setup (The 3 Commands)

Run these in your project root to start governing your AI agents:

### 1. Initialize
Align Rigour with your project's technology stack.
```bash
npx @rigour-labs/cli init
```

### 2. Build the Index
Create a semantic map of your code so AI agents can "reason" about your architecture.
```bash
npx @rigour-labs/cli index --semantic
```

### 3. Launch Studio
Start the visual dashboard to monitor AI tool calls in real-time.
```bash
npx @rigour-labs/cli studio
```

---

## 3. Fast Verification

To see Rigour in action immediately:

1. Create a "messy" file `bad.py`:
   ```python
   def compute(a, b, c, d, e, f, g, h, i, j):
       # Too many parameters!
       pass
   ```
2. Run a check:
   ```bash
   npx @rigour-labs/cli check
   ```
3. **Result**: Rigour will flag the complexity violation and offer a "Fix Packet" for your AI agent to follow.

---

## Next Steps
- **[CLI Commands](/cli/commands)**: Full reference of all options.
- **[Governance Studio](/concepts/governance-studio)**: How to use the visual control room.
- **[MCP Server](/mcp/mcp-server)**: Connecting Rigour directly to Cursor or Claude Code.


---

## INTRO

# üõ°Ô∏è Rigour

**The Control Room for AI-Assisted Engineering.**

Rigour is a high-fidelity governance platform that ensures AI agents (Cursor, Claude, VS Code) follow your project's engineering standards. It bridges the gap between AI creativity and production-grade reliability.

---

## ‚ö° Quick Start (60 Seconds)

You don't need to read a book. Just run these 3 commands in your project root:

### 1. Initialize
Align Rigour with your project's role (API, UI, etc.) and paradigm (OOP, Functional).
```bash
npx @rigour-labs/cli init
```

### 2. Index
Build a semantic map of your codebase so AI agents can "reason" about your patterns.
```bash
npx @rigour-labs/cli index --semantic
```

### 3. Govern (Launch Studio)
Open the visual Mission Control to shadow AI agents and arbitrate decisions in real-time.
```bash
npx @rigour-labs/cli studio
```

---

## üöÄ Key Features

*   **Universal Semantic Search**: Ask your codebase questions in natural language.
*   **Live Shadowing**: Watch every AI tool call and decision in a real-time audit trail.
*   **Human-in-the-Loop (HITL)**: Approve or Reject AI changes directly from the browser.
*   **Polyglot Support**: High-fidelity indexing for Python, Go, Rust, Java, C++, TypeScript, and more.

---

## üõ°Ô∏è "Local Honest" Governance

Rigour is built on a "Local-First" philosophy. We believe that engineering governance should be private, instantaneous, and strictly under your control.

*   **No Login Required**: Start governing in 60 seconds without creating an account.
*   **Zero-Telemetry**: Your source code and command history never leave your machine.
*   **Air-Gapped Sync**: The "Local Bridge" between your IDE and Studio happens entirely on your local filesystem.

*This isn't just a feature‚Äîit's our trust moat.*

---

## üìñ Where to Go Next?

- **[Installation Guide](/getting-started)**: For global setup and MCP server configuration.
- **[Governance Studio](/concepts/governance-studio)**: How to use the visual dashboard.
- **[Pattern Index](/cli/index-command)**: Deep dive into semantic indexing.

*Rigour makes Vibe Coding a thing of the past. Professionalize your agentic workflow today.* ü¶æ


---

## CLI/CI-INTEGRATION

```
---
sidebar_position: 2
---

# Production CI/CD Integration

Rigour is designed to be the final gate in your CI/CD pipeline, ensuring that NO code‚Äîhuman or AI‚Äîreaches production without passing engineering audits.

## GitHub Actions: The "Rigour Gate"

Add this workflow to your `.github/workflows/rigour.yml` to enforce standards on every PR.

```yaml
name: Rigour Quality Gate
on: [pull_request]

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
## Advanced CI Patterns

### ü¶ä GitLab CI/CD
Rigour integrates natively with GitLab's job system. Ensure you use the `node:20` image or higher.

```yaml
# .gitlab-ci.yml
rigour-audit:
  stage: test
  image: node:20
  script:
    - npm ci
    - npx @rigour-labs/cli check --ci --json > rigour-report.json || true
    - # Fail the job if the status is FAIL in the JSON
    - if [ "$(grep -o '"status":"FAIL"' rigour-report.json)" ]; then exit 1; fi
  artifacts:
    when: always
    paths:
      - rigour-report.json
      - rigour-fix-packet.json
```

### üèóÔ∏è Jenkins (Pipeline)
For Jenkins, we recommend using the `sh` step with a return status check.

```groovy
pipeline {
    agent any
    stages {
        stage('Rigour Audit') {
            steps {
                script {
                    def status = sh(script: "npx @rigour-labs/cli check --ci", returnStatus: true)
                    if (status == 1) {
                        unstable("Rigour: Engineering violations found.")
                    } else if (status > 1) {
                        error("Rigour: System/Config error occurred.")
                    }
                }
            }
        }
    }
}
```

---

## Mechanical Review: Parsing the Report

When running in `--json` mode, Rigour produces a rich diagnostic object. You can use `jq` to create custom CI dashboard messages.

### Example: Count failures per file
```bash
cat rigour-report.json | jq '.failures | group_by(.files[0]) | map({file: .[0].files[0], count: length})'
```

### Example: Extract all hints for a Slack notification
```bash
cat rigour-report.json | jq -r '.failures[] | "üö® \(.title): \(.hint)"'
```

---

## Security: The "Snapshot Guard"
In a shared CI environment, Rigour verifies the **Integrity of the Change**.
- **`max_files_changed_per_cycle`**: If a PR touches more than 10 files (default), Rigour identifies this as "high-risk" and requires manual override or refactoring.
- **`protected_paths`**: Rigour prevents AI agents from modifying sensitive CI infrastructure files (like `.github/` or `rigour.yml` itself), even if the agent has filesystem access.


---

## CLI/COMMANDS

# CLI Commands

Complete reference for all Rigour CLI commands.

## `rigour check`

Validate staged changes against safety rules.

```bash
rigour check [options]
```

### Options

| Flag | Description |
|------|-------------|
| `--ci` | CI mode with strict exit codes |
| `--json` | Output results as JSON |
| `--interactive` | **New**: Rich, interactive terminal output |
| `--config <path>` | Custom config file path |

### Examples

```bash
# Basic check
npx @rigour-labs/cli check

# CI pipeline
npx @rigour-labs/cli check --ci --json

# Custom config
npx @rigour-labs/cli check --config ./custom-rigour.yaml
```

---

## `rigour init`

Initialize Rigour in your project. This command creates a `rigour.yml` file and can automatically detect your project's role and coding paradigm.

```bash
npx @rigour-labs/cli init [options]
```

### Options

| Flag | Description |
|------|-------------|
| `--preset <name>` | Explicitly set a **Project Role** (`api`, `ui`, `infra`, `data`) |
| `--paradigm <name>` | Explicitly set a **Coding Paradigm** (`oop`, `functional`) |
| `--force` | Overwrite existing `rigour.yml` config |

### Project Roles (`--preset`)
Roles define the high-level engineering standards and gate thresholds.

| Role | Target | Key Differentiators |
|:---|:---|:---|
| `api` | Backend Services | 400 line limit, strict SOLID enforcement |
| `ui` | Web/Frontends | 300 line limit, JSX-aware complexity |
| `infra` | IaC (Terraform) | Protected `.github/` and CI configs |
| `data` | Data/ML Pipelines | 500 line limit, reproducibility gates |

### Coding Paradigms (`--paradigm`)
Paradigms layer specific AST (Abstract Syntax Tree) rules on top of your role.

| Paradigm | Key Gates |
|:---|:---|
| `oop` | Max inheritance depth (3), Method counts (10/class) |
| `functional` | Max nesting (3), Function length (40 lines) |

### Examples

```bash
# Default initialization (Auto-discovery)
npx @rigour-labs/cli init

# Explicitly use API role with OOP paradigm
npx @rigour-labs/cli init --preset api --paradigm oop
```

### Framework Compatibility (Safe Scaffolding)
Many framework CLI tools (like `create-next-app` or `npm init vite`) require the target directory to be **completely empty**. If you run `rigour init` first, these tools will fail.

**Best Practice**:
1. Run your framework initializer first.
2. Run `rigour init` second to layer your engineering standards on top.

**If you already initialized Rigour**:
Simply move `rigour.yml` and the `docs/` folder aside temporarily, run your framework command, and move them back. AI Agents using Rigour have a built-in workflow to handle this automatically.

---

## `rigour explain`

Get detailed explanation of validation results.

```bash
npx @rigour-labs/cli explain [options]
```

### Options

| Flag | Description |
|------|-------------|
| `--fix-packet <path>` | Analyze a specific fix packet |
| `--verbose` | Include AST details |

### Examples

```bash
# Explain last check
npx @rigour-labs/cli explain

# Analyze fix packet
npx @rigour-labs/cli explain --fix-packet ./fix.json
```

---

## `rigour run`

The **Supervisor Loop**. Executes an AI agent and automatically iterates until quality gates pass.

```bash
npx @rigour-labs/cli run [options] -- <agent-command>
```

### The Iterative Refinement Cycle
When you use `rigour run`, Rigour manages a stateful refinement loop:
1.  **Deploy**: Your agent (e.g., Claude Code) is executed with your prompt.
2.  **Snapshot**: Rigour monitors file changes in real-time.
3.  **Audit**: Quality gates are checked against the resulting state.
4.  **Refine**: If gates fail, Rigour generates a `rigour-fix-packet.json` (Diagnostic) and automatically re-invokes the agent to fix the violations.
5.  **Finish**: The loop exits when all gates `PASS` or the maximum iterations are reached.

### Options

| Flag | Default | Description |
|:---|:---:|:---|
| `--iterations <n>` | `3` | Maximum number of refinement cycles |
| `--fail-fast` | `false` | Terminate instantly on the first violation |

### Safety Rails
`rigour run` prevents "agent explosions" by monitoring the cycle delta. If an agent changes more than `max_files_changed_per_cycle` (set in `rigour.yml`), the loop is instantly aborted.

---

## `rigour studio`

The **Governance Control Room**. A premium, local-first dashboard for real-time AI shadowing, pattern discovery, and HITL (Human-in-the-Loop) arbitration.

```bash
rigour studio [options]
```

### The Shadowing Experience
Rigour Studio provides a high-fidelity interface for monitoring AI agents as they work on your local machine:
1.  **Live Shadowing**: See tool calls and filesystem changes as they happen.
2.  **Pattern Index**: Visually search and explore project patterns (supports AI-powered Semantic Search).
3.  **Governance Audit**: Deep-dive into proposed changes before they are committed.
4.  **HITL Arbitration**: Manually **Approve (Override)** or **Reject** AI actions directly from the UI.

### Options

| Flag | Default | Description |
|:---|:---:|:---|
| `--port <n>` | `3000` | Port to run the Studio dashboard on |
| `--dev` | `true` | Run in development mode (recommended for v2) |

### Key Features
- **Memory Bank**: Visualize the agent's persistent memory and contextual state.
- **Quality Gates**: Real-time visualization of gate violations and compliant code.
- **Diff Viewer**: High-fidelity Monaco-based diffing for every AI interaction.

---

---

## Technical Reference: The Quality Score

Rigour calculates a **Total Quality Score (0-100)** for every audit run. This score is included in the JSON report and displayed in human-readable summaries.

### How it's calculated:
- **Base Score**: 100
- **Structural Violations**: -5 points per failure (e.g., SME_COGNITIVE_LOAD).
- **Security Violations**: -10 points per failure (e.g., SME_SECURITY_SINK).
- **Dynamic Violations**: -15 points per blind spot (e.g., DYNAMIC_COVERAGE_LOW).

| Code | Meaning | Context |
|:---:|:---|:---|
| `0` | **PASS** | All quality gates were satisfied (Score > Threshold). |
| `1` | **FAIL** | One or more engineering violations were found. |
| `2` | **CONFIG_ERROR** | `rigour.yml` is missing or invalid. |
| `3` | **INTERNAL_ERROR** | Unexpected diagnostic or filesystem failure. |

See the [Exit Codes Guide](/cli/exit-codes) for advanced usage.


---

## CLI/EXIT-CODES

# Exit Codes: Deep Dive

Rigour uses standardized exit codes to enable seamless integration with any orchestration layer (CI/CD, K8s, local git hooks).

## Reference Table

| Code | Status | Meaning | Action Required |
|:---:|:---:|:---|:---|
| `0` | **PASS** | Audits satisfied. | Safe to merge/deploy. |
| `1` | **FAIL** | Engineering violations found. | Agent or human must refactor. |
| `2` | **CONFIG_ERROR** | Invalid `rigour.yml`. | Fix YAML syntax or schema. |
| `3` | **INTERNAL_ERROR** | System/Filesystem crash. | Check permissions or OOM. |

---

## Technical Details

### Code 1: Audit Failure (Expected)
This is a **logical failure**. It indicates that the audit logic worked perfectly but the code quality was insufficient.
- **In CI**: This should block the build.
- **In Loop**: This triggers a refinement cycle in `rigour run`.

### Code 2: Configuration Error
Triggered when the Zod-based configuration parser fails.
- **Common Cause**: Using a string where a number is expected (e.g. `complexity: "high"` instead of `complexity: 10`).
- **Fix**: Run `rigour guide` to validate your configuration interactively.

### Code 3: Internal Error
These are unexpected exceptions (e.g., `EMFILE` for too many open files during AST parsing).
- **Troubleshooting**: If this persistent in CI, ensure your runner has sufficient memory and file handle limits.

---

## Universal Shell Handling

### üêö Bash / Zsh (Linux & macOS)
Use `$?` to capture the last exit code.

```bash
npx @rigour-labs/cli check --ci
case $? in
  0) echo "Audit passed!" ;;
  1) echo "Violations detected." && exit 1 ;;
  2) echo "Config is broken." && exit 1 ;;
  *) echo "Unexpected system error." && exit 1 ;;
esac
```

### üîπ PowerShell (Windows / Azure DevOps)
Use `$LASTEXITCODE` for reliability in Windows environments.

```powershell
npx @rigour-labs/cli check --ci
if ($LASTEXITCODE -eq 0) {
    Write-Host "Rigour PASS" -ForegroundColor Green
} elseif ($LASTEXITCODE -eq 1) {
    Write-Error "Audit Failed: Violations found"
} else {
    Write-Error "System Error ($LASTEXITCODE)"
}
```

---

## Integration Pro-tip: "The Supervisor Pattern"
When building custom wrappers around Rigour, differentiate between Code 1 and Codes 2/3.
- If **Code 1**: Provide the `rigour-fix-packet.json` to the agent.
- If **Code 2/3**: Fail the pipeline immediately without re-invoking the agent, as a system fix is required.


---

## CLI/INDEX-COMMAND

# CLI: Index Command

Build a semantic index of your codebase patterns for AI-powered search and analysis.

## Overview

The `rigour index` command scans your codebase and builds a searchable index of:
- **Universal Polyglot Support**: High-fidelity indexing for **Python, Go, Rust, Java, C++, TypeScript** and more.
- **AI-Powered Semantic Search**: Natural language pattern discovery using local vector embeddings.
- **Functions & signatures**: Classes, methods, and architectural patterns.
- **Architecture**: Dependencies, versioning, and code conventions.

This index powers the Pattern Index MCP tools (`rigour_find_patterns`, `rigour_detect_staleness`).

## Usage

```bash
# Build the index with default settings
rigour index

# Build with semantic embeddings (slower, more powerful)
rigour index --semantic

# Specify output location
rigour index --output .rigour/pattern-index.json
```

## Options

| Option | Description | Default |
|--------|-------------|---------|
| `--semantic` | Enable semantic embeddings for natural language search | `false` |
| `--output` | Custom output path for the index file | `.rigour/pattern-index.json` |

## How It Works

1. **Discovery**: Scans your project for code files (respects `.gitignore`).
2. **Parsing**: Extracts functions, classes, and patterns using AST parsing.
3. **Indexing**: Builds a searchable structure with metadata.
4. **Embeddings** (optional): Generates vector embeddings for semantic search.

## Index Structure

The generated index contains:

```json
{
  "version": "1.0.0",
  "generatedAt": "2026-01-28T09:00:00Z",
  "entries": [
    {
      "name": "AuthService.validateToken",
      "type": "function",
      "path": "src/services/auth.ts",
      "signature": "(token: string) => Promise<User>",
      "complexity": 5,
      "embedding": [0.123, 0.456, ...]
    }
  ]
}
```

## Best Practices

1. **Run on CI**: Regenerate the index on each merge to `main`.
2. **Commit the Index**: Include `.rigour/pattern-index.json` in version control.
3. **Use Semantic Mode**: Enable `--semantic` for codebases > 10k LOC.

## Integration with MCP

Once indexed, AI agents can use:
- `rigour_find_patterns` ‚Äî Search patterns by keyword or semantically.
- `rigour_detect_staleness` ‚Äî Find outdated or deprecated patterns.

```bash
# Build and use immediately
rigour index --semantic
```


---

## CLI/INTERACTIVE

# Interactive Tools

Rigour includes interactive commands and flags to help you set up and troubleshoot your project's engineering standards.

## `rigour check --interactive`

The "Human Mode" of Rigour. It provides rich, colorful terminal output designed for manual code reviews and local debugging.

```bash
npx @rigour-labs/cli check --interactive
```

### Key Features:
- **Visual Callouts**: Important violations are highlighted with expert hints.
- **Trace Visualization**: Shows the exact logic path (e.g., nesting levels) that triggered a failure.
- **Immediate Resolution**: Provides actionable "Next Steps" for every violation.

---
## `rigour setup`

The automated project bootstrap command.

```bash
npx @rigour-labs/cli setup
```

### What it does:
1.  **Environment Check**: Verifies Node.js, Git, and filesystem permissions.
2.  **Paradigm Detection**: Analyzes your code to detect if you are using OOP, Functional, or procedural patterns.
3.  **Config Generation**: Creates a `rigour.yml` tailored to your stack.
4.  **Handshake Verification**: Ensures that local agents (like Cursor or your shell) can correctly call Rigour tools.

---

## `rigour guide`

Interactive troubleshooting and documentation assistant.

```bash
npx @rigour-labs/cli guide
```

### Features:
- **Violation Help**: Paste a failure ID to get a deep-dive explanation and refactoring examples.
- **Config Helper**: Helps you tune thresholds (like complexity or file lines) using natural language.
- **Best Practices**: Provides tailored advice based on your project's specific preset and paradigm.


---

## CONCEPTS/AST-GATES

# AST Gates: Technical Reference

Syntax-aware validation for code quality. Rigour uses high-fidelity AST parsing to enforce standards that regular regex-based linters often miss.

## Language Support: Full Parity

Rigour is truly technology-agnostic. We use a hybrid validation engine that combines native structural analysis with universal parsing.

### AST-Aware Languages
Rigour provides high-fidelity structural checks (Complexity, Nesting, Params) for all major enterprise languages:

| Ecosystem | Language | Parser | Status |
|:---|:---|:---|:---|
| **Web** | TypeScript, JS, React | `typescript` API | ‚úÖ Production |
| **Backend** | Python, Go, Rust | `tree-sitter` (WASM) | ‚úÖ Production |
| **Enterprise** | Java, C#, C, C++ | `tree-sitter` (WASM) | ‚úÖ Production |
| **Mobile/Script** | Swift, Kotlin, Ruby, PHP | `tree-sitter` (WASM) | ‚úÖ Production |

> [!TIP]
> **Total Agnosticism**: If your language isn't on the list, you can still use [Custom Command Gates](/reference/configuration#custom-command-gates-agnosticism) to wrap any third-party linter or compiler into the Rigour supervisor loop.

---

## Safety Rails (Core)

### `complexity`
- **ID**: `SME_COGNITIVE_LOAD` (Universal) or `AST_COMPLEXITY` (TS/JS)
- **Check Logic**: Calculates Cognitive Complexity (Cyclomatic + Nesting).
- **Fail Condition**: Any single function's complexity > `gates.ast.complexity`.
- **Primary Goal**: Prevent "God Functions" that agents tend to generate during large refactors.

### `max_params`
- **ID**: `AST_MAX_PARAMS`
- **Check Logic**: Counts arguments in function declarations.
- **Fail Condition**: Parameter count > `gates.ast.max_params`.
- **Primary Goal**: Enforce dependency injection or object-based configuration over long argument lists.

### `max_function_lines`
- **ID**: `AST_MAX_FUNCTION_LINES`
- **Check Logic**: Counts physical lines of code.
- **Fail Condition**: Function depth > `gates.ast.max_function_lines`.

---

## SME Intelligence Gates (Universal)

Rigour's Universal AST engine (powered by Tree-sitter WASM) implements advanced Subject Matter Expert (SME) logic across 10+ languages.

### Cognitive Complexity üß†
Unlike simple Cyclomatic complexity, Cognitive complexity measures how hard code is for a human (or an AI agent) to understand.
- **Logic**: Base Cyclomatic score + (Nesting Depth * 2).
- **Benefit**: Discriminates against deeply nested code (callback hell, nested if/else) that increases technical debt.

### Security Sinks üõ°Ô∏è
Proactively identifies code that introduces security vulnerabilities.
- **Python**: Detects `eval()`, `exec()`, and `os.system()`.
- **Go**: Flags usage of the `unsafe` package and shell execution.
- **Rust**: Identifies `unsafe` blocks that bypass the borrow checker.
- **Java**: Flags native method declarations and `Runtime.exec()`.

### Ecosystem Best Practices (SME)
Enforces language-specific professional standards:
- **Go Mandatory Errors**: Ensures `err` returned from functions is actually checked.
- **Python Defaults**: Flags mutable default arguments (e.g., `def list(a=[])`).
- **Rust Reliability**: Discourages the use of `.unwrap()` in favor of safe error handling.
- **Java Hygiene**: Detects empty `catch` blocks (exception swallowing).

---

## The Quality Handshake (SAST+DAST)
Rigour provides a **double-check** loop. High-complexity files are automatically required to have higher dynamic test coverage. See the [Quality Handshake guide](/examples/quality-handshake).

---

## Security & Hygiene

### `no-eval`
**Banned Nodes**: `CallExpression` where callee is `eval` or `new Function`.

### `no-process-env-write`
**Banned Nodes**: `AssignmentExpression` targeting `process.env`.
- **Reason**: Modification of environment variables at runtime is a side-effect that creates unpredictable agent behavior.

### `no-fs-write-sync`
**Banned Nodes**: `fs.writeFileSync`, `fs.appendFileSync`, etc.
- **Goal**: Force agents to use async patterns which are more compatible with Rigour‚Äôs snapshotting engine.

---

## Advanced: Logic Extraction
Rigour's AST engine is designed specifically to help agents **refactor**. 

When a `complexity` gate fails, Rigour doesn't just say "Fix it." The Fix Packet contains instructions like:
> "Function 'processOrder' is too complex. Extract the 'TaxCalculation' block into a separate function to lower the score."


---

## CONCEPTS/CONTEXT-AWARENESS

AI agents often fall into the trap of **"Vibe Coding"**‚Äîwriting code that looks correct but ignores the existing patterns, standards, and lexicon of your specific project. This is a form of **Context Drift**.

Rigour's **Universal Context Awareness Engine** prevents this by dynamically mining your codebase to build a "Golden Record" of established patterns.

## The Problem: "Guess and Hope" (Vibe Coding)

The most common frustration with AI agents is the **narrative vs. reality** gap. An agent will confidently state: *"I have fixed the type errors and reformatted the code. You can push now."*

But in reality:
- **MyPy/Lint** is still fails with 13 errors.
- **Context Drift**: The agent used a variable name that doesn't exist or doesn't follow project standards.
- **CI Failures**: You lose 10 minutes waiting for a CI pipeline that was doomed from the start.

Rigour acts as the **firewall** between the agent's creative guesses and your project's technical reality.

1. **Discovery**: Rigour scans your environment files, CI configs, and existing source code.
2. **Anchoring**: It identifies `BASE_URL` as a project-standard "Anchor".
3. **Verification**: When the agent introduces a variation like `BASE_URL_PRODUCTION` or `PROD_BASE_URL`, Rigour flags it as **Context Drift**.

## How it Works

Rigour doesn't rely on hardcoded rules. Instead, it uses **Statistical Normalcy**:

- **Anchor Discovery**: Scans for variables, class naming patterns, and service structures that appear frequently or are defined in "Truth Sources" (like `.env` or `Dockerfile`).
- **Drift Detection**: Flags new code that diverges significantly from discovered anchors.
- **Pattern Collision**: Warns when new names are "too similar" to existing ones but incorrectly formatted.

## Configuration

Context awareness is enabled by default. You can tune it in `rigour.yml`:

```yaml
gates:
  context:
    enabled: true
    sensitivity: 0.8  # Threshold for drift detection
    mining_depth: 100 # Number of files to sample for patterns
```

## Why it Matters

Dynamic context awareness turns Rigour from a simple "linter on steroids" into a **Strategic Quality Gate**. It ensures that as your codebase grows, your AI agents stay anchored to the reality of your project, not the "vibe" of their training data.


---

## CONCEPTS/ENVIRONMENT-ALIGNMENT

# Environment Alignment

**"Works on my machine"** is the most common lie in AI-generated development. Environment Alignment is Rigour's mechanism for ensuring that your agent's local environment is a perfect mirror of your project's technical requirements.

## The Problem: Environment Drift

Imagine your CI pipeline expects **Ruff 0.14.0**. Your AI agent is running **Ruff 0.1.0** locally. 

- The agent claims: *"I have formatted the code and verified it passes."*
- You push to remote.
- CI fails 5 minutes later because the older version of Ruff missed patterns detected by the newer one.

This is **Environment Drift**. It leads to a "Guess and Hope" cycle that kills developer productivity.

## How Rigour Fixes It

Rigour doesn't just run tools; it verifies the **contract** of the tool itself before execution.

### 1. Dynamic Contract Discovery
Rigour parses your project's configuration files to discover the required versions of your tools:
- `pyproject.toml` (Ruff, Mypy, Black)
- `package.json` (Node, Prettier, ESLint)
- `.tool-versions` (Asdf, RTX)

### 2. Pre-flight Verification
Before running any gates, Rigour executes a "Pre-flight Check". If the local environment deviates from the project contract (e.g., wrong version, missing binary), Rigour fails the cycle immediately with a **Fatal Alignment Error**.

## Why It Matters

By enforcing Environment Alignment, Rigour transforms your AI agent from a "creative guesser" into a **deterministic engineer**. It ensures that if a check passes locally on the agent's machine, it **will** pass in CI.

---
*"Rigour turns a claim of victory into a proof of execution."*


---

## CONCEPTS/FIX-PACKET

# Fix Packet (V2)

The high-fidelity communication bridge between Rigour and an AI agent.

## Overview

Unlike a traditional diff or patch, a **Rigour Fix Packet** is a **Diagnostic Format**. It does not provide the solution; instead, it provides the agent with structured, prioritized metadata about engineering violations that must be resolved to achieve a `PASS` state.

## Schema (V2)

```json
{
  "version": 2,
  "goal": "Achieve PASS state for all quality gates",
  "violations": [
    {
      "id": "ast-complexity",
      "gate": "ast",
      "severity": "high",
      "title": "Complexity Cap Exceeded",
      "details": "Function 'processData' has cyclomatic complexity of 15 (max: 10).",
      "files": ["src/parser.ts"],
      "metrics": {
        "current": 15,
        "max": 10
      },
      "instructions": [
        "Extract nested logic into a separate utility function.",
        "Replace the switch statement with a lookup table or polymorphic behavior."
      ]
    }
  ],
  "constraints": {
    "no_new_deps": true,
    "max_files_changed": 10,
    "protected_paths": [".github/**", "docs/**"]
  }
}
```

## Why Diagnostics over Patches?

Rigour follows a **Stateless** loop philosophy:
1. **Autonomy**: We trust the agent's ability to refactor. We simply provide the "Engineering Specs" it violated.
2. **Safety**: By providing violations rather than code, we ensure the agent remains responsible for the final implementation.
3. **Precision**: High-fidelity metrics (like exact complexity scores) help agents make surgical fixes rather than "guess-and-check" refactoring.

## Key Components

### `violations[]`
A list of specific gate failures. Each violation includes:
- **`details`**: Context-specific error message.
- **`instructions`**: Heuristic-based advice on how to resolve the issue.
- **`metrics`**: The raw data (e.g., line counts) that triggered the failure.

### `constraints`
Safety rails that the agent MUST respect during the refactoring process (e.g., not touching `docs/` or adding new `package.json` dependencies).

## Usage
Agents retrieve the latest Fix Packet by calling `rigour_get_fix_packet` (MCP) or by running `rigour explain` (CLI).


---

## CONCEPTS/GOVERNANCE-STUDIO

# Governance Studio

The visual "Mission Control" for your AI engineering workflows. The Studio provides real-time observability and human-in-the-loop (HITL) governance with zero configuration.

---

## ‚ö° Quick Launch
```bash
npx @rigour-labs/cli studio
```
*Studio runs locally at `http://localhost:3000`.*

---

## üî¶ Real-Time Shadowing
Watch every decision your AI agent makes in a live audit trail.
- **Audit Log**: Stream tool calls and file changes as they happen.
- **Transparency**: See the AI's internal "thought process" and tool outputs.

## üõ°Ô∏è Human-in-the-Loop (HITL) 
Don't just watch‚Äîgovern.
- **Violation Alerts**: Red badges flag any AI move that breaks your project rules.
- **Arbitration**: Approve (Override) or Reject changes directly from the UI.
-  **Seamless Sync**: Decisions are sent back to the agent in real-time.

## üß† Pattern Discovery
Search and reason about your codebase using AI search.
- **Semantic Mode**: Ask questions in natural language like *"How is the database initialized?"*
- **Pattern Index**: A consolidated view of all classes, methods, and architectural patterns.

## üíæ Engineering Memory
A persistent whiteboard for your project's architectural decisions.
- **MCP Memory**: Store decisions (e.g., *"We use ChromaDB for local dev"*) that survive across different AI chat sessions.
- **Visual Bank**: Review and manage your project's technical context in a clean interface.

---

## üîí Private by Design
Rigour Studio is **local-first**. Your code, audit logs, and decisions never leave your machine.


---

## CONCEPTS/IDE-SUPPORT

# Full IDE Support

Rigour CLI supports all major AI coding assistants out of the box. Run `rigour init` to automatically generate configuration files for your detected IDE.

## Supported IDEs

| IDE/Tool | Config Location | Format |
|----------|----------------|--------|
| **Cursor** | `.cursor/rules/rigour.mdc` | MDC with frontmatter |
| **Cline** | `.clinerules` | Markdown |
| **Claude Code** | `CLAUDE.md` | Markdown |
| **Gemini Code Assist** | `.gemini/styleguide.md` | Markdown |
| **OpenAI Codex / Aider** | `AGENTS.md` | Universal standard |
| **Windsurf** | `.windsurfrules` | Markdown |
| **VS Code** | `docs/AGENT_INSTRUCTIONS.md` | Markdown |

## Usage

### Auto-detection

```bash
npx @rigour-labs/cli init
```

Rigour auto-detects your IDE based on:
- Existing config files (`.cursor/`, `.vscode/`, etc.)
- Environment variables
- Project markers

### Target Specific IDE

```bash
npx @rigour-labs/cli init --ide cursor
npx @rigour-labs/cli init --ide claude
npx @rigour-labs/cli init --ide gemini
npx @rigour-labs/cli init --ide codex
npx @rigour-labs/cli init --ide windsurf
```

### Generate All Configs

```bash
npx @rigour-labs/cli init --ide all
```

This creates config files for all supported IDEs, useful for teams with mixed tooling.

## AGENTS.md - The Universal Standard

`AGENTS.md` is emerging as the universal format for AI coding assistants. It's used by:
- OpenAI Codex CLI
- Aider
- Many other AI tools

Rigour always generates `docs/AGENT_INSTRUCTIONS.md` as a universal fallback, and `AGENTS.md` when using Codex mode.

## What Gets Generated

Each IDE config file includes:
- Quality gate enforcement rules
- Code quality standards
- Debugging best practices
- Collaboration guidelines
- Rigour CLI commands

## Claude Code Setup

Claude Code reads project context from `CLAUDE.md`. Rigour generates a comprehensive file including:

```markdown
# CLAUDE.md - Project Instructions for Claude Code

This project uses Rigour for quality gates.

## Commands

\`\`\`bash
# Verify quality gates
npx @rigour-labs/cli check
\`\`\`
```

## Gemini Code Assist Setup

Gemini reads from `.gemini/styleguide.md`:

```markdown
# Gemini Code Assist Style Guide

This project uses Rigour for quality gates.

## Required Before Completion

Always run `npx @rigour-labs/cli check` before marking any task complete.
```


---

## CONCEPTS/MODES

# Advisor vs. Supervisor

Rigour operates in two distinct modes depending on how you integrate it into your workflow.

## 1. Advisor Mode (MCP)

In **Advisor Mode**, Rigour acts as a high-fidelity consultant for your AI agent.

- **Role**: Pre-flight Validator.
- **Trigger**: The agent proactively calls Rigour tools (e.g., `rigour_check`) to verify its work.
- **UX**: Seamlessly integrated into IDEs like **Cursor** or **Cline**.
- **Philosophy**: Agent-driven. The agent asks: *"Is this code good enough to commit?"*

### When to use:
- Interactive development in an IDE.
- Complex refactors where the agent needs frequent feedback before finishing a turn.

---

## 2. Supervisor Mode (CLI Loop)

In **Supervisor Mode**, Rigour acts as the "governor" of the entire process.

- **Role**: Iterative Controller.
- **Trigger**: You run `rigour run -- <agent-command>`.
- **UX**: Terminal-based, wrapping agents like **Claude Code**.
- **Philosophy**: Tool-driven. Rigour says: *"You are not finished until these gates pass. Here is what you failed."*

### When to use:
- Headless automation or CI/CD pipelines.
- Terminal-based coding agents.
- Ensuring 100% compliance without manual re-prompting.

---

## Comparison Summary

| Feature | Advisor (MCP) | Supervisor (CLI) |
|:---|:---|:---|
| **Primary Tool** | `@rigour-labs/mcp` | `@rigour-labs/cli` |
| **Control Flow** | Agent calls Rigour | Rigour wraps Agent |
| **UX** | VS Code / JetBrains / Desktop | Terminal / Shell |
| **Feedback** | Interactive Response | Loop Iterations |
| **Example Agent** | Cursor, Cline, Gemini Desktop | Claude Code, Shell Agents |


---

## CONCEPTS/PRESETS

# Presets, Roles & Paradigms

Rigour uses a hierarchical configuration system that combines **Project Roles**, **Coding Paradigms**, and **Universal Standards** to provide expert-level supervision with zero initial configuration.

## The Hierarchy of Rigour

When you run an audit, Rigour assembles your quality gates in this order:
1.  **Universal Config**: Base standards (e.g., forbidding `TODO`s, base complexity).
2.  **Project Role (`preset`)**: Industry-standard thresholds for your project type (API, UI, etc.).
3.  **Coding Paradigm (`paradigm`)**: Language-agnostic structural rules (OOP, Functional).
4.  **Local Overrides**: Your project's specific `rigour.yml` settings.

---

## Universal Standards (`UNIVERSAL_CONFIG`)

Every Rigour project starts with these "hygiene" gates:

| Gate | Default Value | Description |
|:---|:---:|:---|
| `max_file_lines` | `500` | Maximum allowed lines per file |
| `forbid_todos` | `true` | Prevents merging code with `TODO` markers |
| `forbid_fixme` | `true` | Prevents merging code with `FIXME` markers |
| `max_files_changed` | `10` | Safety rail for AI agent "explosions" |

---

## Project Roles (`preset`)

Roles define the "personality" of your project. They are detected by the existence of specific files or dependencies.

### `api` (Backend Services)
Optimized for high-reliability, maintainable backend logic.
- **Detection**: `express`, `nestjs`, `go.mod`, `requirements.txt`, `pyproject.toml`, `main.go`.
- **Thresholds**:
  - `max_file_lines`: `400`
- **Required Docs**: `docs/SPEC.md`, `docs/ARCH.md`, `README.md`
- **Roadmap**: Service layer enforcement (Controllers ‚Üí Services).

### `ui` (Web/React/Next.js)
Optimized for component-based modularity and JSX complexity.
- **Detection**: `react`, `next`, `vue`, `svelte`, `tailwind.config.js`, `vite.config.ts`.
- **Thresholds**:
  - `max_file_lines`: `300`
- **Required Docs**: `docs/SPEC.md`, `docs/ARCH.md`, `README.md`
- **Roadmap**: Prop-drilling detection (Max depth 5).

### `infra` (IaC/DevOps)
Focuses on safety and preventing accidental infrastructure destruction.
- **Detection**: `Dockerfile`, `docker-compose.yml`, `main.tf`, `k8s/`, `helm/`, `ansible/`.
- **Thresholds**:
  - `max_file_lines`: `300`
- **Required Docs**: `docs/RUNBOOK.md`, `docs/ARCH.md`, `README.md`

### `data` (Data/ML Pipelines)
Optimized for reproducibility and pipeline clarity.
- **Detection**: `ipynb`, `spark`, `pandas`, `dbt_project.yml`, `data/`.
- **Thresholds**:
  - `max_file_lines`: `500`
- **Required Docs**: `docs/DATA_DICTIONARY.md`, `docs/PIPELINE.md`, `README.md`
- **Roadmap**: Stochastic determinism (seed enforcement) and PII leak detection.

---

## Coding Paradigms (`paradigm`)

Paradigms apply syntax-aware AST rules. Rigour scans your source code content to detect the dominant paradigm.

### `oop` (Object-Oriented)
- **Patterns**: `class`, `interface`, `extends`, `constructor`, `private`, `public`.
- **AST Gates**:
  - **Complexity**: `10`
  - **Max Methods**: `10` per class
  - **Max Params**: `5` per method
  - **Inheritance Depth**: `3`
  - **Class Dependencies**: `5`

### `functional`
- **Patterns**: `export const`, `reduce(`, `.pipe(`, `compose(`, `curry(`, `readonly`.
- **AST Gates**:
  - **Complexity**: `8`
  - **Max Functions**: `15` per file
  - **Max Params**: `4` per function
  - **Max Nesting**: `3`
  - **Function Lines**: `40`

---

## Auto-Discovery

The `rigour init` command performs a deep scan of your environment:
1.  **Dependency Scan**: Checks `package.json`, `go.mod`, etc., for Role markers.
2.  **Filesystem Scan**: Looks for config files (e.g., `Dockerfile`) for Role markers.
3.  **Content Heuristics**: Samples top source files to detect coding patterns (e.g., heavy use of `class` vs. `const`) to assign a Paradigm.

To override discovery:
```bash
rigour init --preset api --paradigm oop
```


---

## CONCEPTS/VIBE-CODING-TRAP

# The "Vibe Coding" Trap

**"Vibe Coding"** is when an AI agent claims completion based on its internal narrative rather than external execution. It's the gap between an agent saying *"I'm 100% done"* and your CI pipeline crashing with 13 type errors.

## The Symptoms of Vibe Coding

You know you're stuck in the Vibe Coding Trap when:
- The agent promises "CI will pass now," but it doesn't.
- You spend more time reviewing "hallucinated fixes" than writing code.
- You have to forcefully repeat instructions like "run the tests again" before the agent admits failure.
- The agent guesses variable names based on "vibes" rather than checking the existing project context.

## The Rigour Solution: Execution-Verification

Rigour kills Vibe Coding by injecting a **deterministic firewall** between the agent's output and your codebase.

### Narrative vs. Reality
Rigour ignores what the agent *says* it did. Instead, it measures what the tools *report*:

| Agent Says... | Rigour Checks... | Outcome |
| :--- | :--- | :--- |
| "I've fixed all type errors." | `mypy .` | **FAIL** (13 errors found) |
| "The code is formatted." | `ruff format --check` | **FAIL** (2 files drifted) |
| "I'm using project patterns." | `ContextEngine` | **FAIL** (Redundant variation) |

## The Result: Guaranteed Engineering

When you use Rigour, the agent's definition of "Done" is tethered to your project's technical reality. The agent is forced to cycle through **Fix Packets**‚Äîactually running the tools and fixing the errors‚Äîuntil the system returns a hard **PASS**.

No more guessing. No more patience required. **Rigour adds the engineering.**


---

## EXAMPLES/QUALITY-HANDSHAKE

# The Quality Handshake (SAST + DAST)

A truly production-ready supervisor understands that **Structure (Static)** and **Behavior (Dynamic)** must be verified together. Rigour bridges this gap by cross-referencing AST analysis with runtime test coverage.

## The SME Double-Key Logic
Rigour's `CoverageGate` implements a "Double-Key" verification system:

| Structural Risk (Static) | Required Coverage (Dynamic) | Rationale |
| :--- | :--- | :--- |
| **Simple** (Complexity < 5) | > 50% | Basic validation is sufficient for simple logic. |
| **Complex** (Complexity > 10) | > 80% | Complex branches MUST be proven at runtime. |
| **Critical** (Safety Gate Path) | > 95% | Security-sensitive paths require near-total coverage. |

## üöÄ Live Trace: The Quality Handshake
Watch how Rigour cross-references the `blunders.go` AST with the `lcov.info` dynamic report.

```bash
$ npx rigour check
```

#### Step 1: Identifying "Blind Spots"
Rigour detects that `go/blunders.go` has a **SME_COGNITIVE_LOAD** failure (Complexity: 14).

#### Step 2: Verifying Dynamic Proof
Rigour checks the `lcov.info` and finds:
- File `go/blunders.go` has only **20.00%** coverage.

#### Step 3: Triggering the Handshake Failure
> **[DYNAMIC_COVERAGE_LOW]** Low coverage for high-risk file: `go/blunders.go`
> 
> **Details**: Current coverage: 20%. Required: 80% due to structural risk (Complexity: 14).
> 
> **SME Insight**: You are deploying complex logic without runtime validation. This is a "Blind Spot" refactor.
> 
> **Resolution**: Add unit tests for the nested conditions in `complexNestedLogic`.

---

## Unified Quality Dashboard
Rigour synthesizes these results into a single score:

```json
{
  "status": "FAIL",
  "score": 42.5,
  "summary": {
    "structural_health": "FAIL (3 violations)",
    "test_confidence": "FAIL (1 blind spot)",
    "runtime_resilience": "PASS"
  }
}
```


---

## EXAMPLES/SME-COOKBOOKS

# SME Best Practices (Cookbook)

Rigour isn't just a linter; it's an **Engineering Subject Matter Expert (SME)**. These examples show how Rigour enforces professional standards across ecosystems.

## Cloud-Native Go SME
Rigour enforces strict concurrency safety and error handling patterns for Go.

```yaml
# rigour.yml
gates:
  ast:
    complexity: 8
    max_params: 4
  rules:
    - id: GO_ERROR_CHECK
      pattern: "if err != nil"
      enforce: mandatory
```

### What Rigour Catches:
1. **Missing Error Checks**: Flags any function call returning `error` that isn't immediately followed by `if err != nil`.
2. **Unsafe Sinks**: Identifies usage of `os.exec` or `unsafe` pointers in sensitive modules.
3. **Cognitive Complexity**: Flags deeply nested `select` or `for` loops that increase technical debt.

---

## Data Engineering Python SME
Enforce high-quality, bug-free Python patterns for data pipelines.

```yaml
# rigour.yml
paradigm: functional
gates:
  ast:
    complexity: 10
```

---

## üöÄ Live Execution Trace: Catching Blunders

Watch how Rigour's SME supervisors intercept the `blunders.go` and `blunders.py` files in real-time.

### 1. The Headless Supervisor Loop
Run Rigour in your test suite directory to see the SME in action.

```bash
$ npx rigour check --interactive
```

#### Step 1: Scanning Go Architecture
> **[SME_BEST_PRACTICE]** Ecosystem anti-pattern detected
> **File**: `go/blunders.go:L5` 
> **Logic**: Function `handleRequest` calls `fetchData` but ignores the `error` return.
> **Expert Hint**: Mandatory error checking: Enforce `if err != nil` after every fallible call.

#### Step 2: Evaluating Python Safety
> **[SME_SECURITY_SINK]** Unsafe function call detected: `eval(code)`
> **File**: `python/blunders.py:L2`
> **Logic**: Dynamic execution detected. This bypasses structural validation.
> **Expert Hint**: Avoid using shell execution or eval. Use safe alternatives like `ast.literal_eval`.

#### Step 3: Measuring Cognitive Load
> **[SME_COGNITIVE_LOAD]** Method `complexNestedLogic` is too complex (14)
> **File**: `go/blunders.go:L16`
> **Logic**: 4-level nesting (if > if > if > for) detected.
> **Expert Hint**: Flatten logical branches and extract nested loops into focused sub-methods.

---

## Technical Contract Summary
When you adopt Rigour, you aren't just adding a linter; you are adding a **Project SME** that guards your production intent.


---

## GATES/RETRY-LOOP-BREAKER

# Retry Loop Breaker Gate

The **Retry Loop Breaker** gate detects when an AI agent is stuck in a retry loop‚Äîrepeatedly failing at the same operation without changing approach‚Äîand forces them to consult official documentation before continuing.

> [!NOTE]
> This gate is **enabled by default** and works universally across all operation types, not just specific tools or languages.

## The Problem

When AI agents encounter failures, they often:
1. Retry the same approach
2. Make minor tweaks without understanding the root cause
3. Continue guessing instead of consulting authoritative sources

This leads to **"vibe coding"**‚Äîsolving problems through trial and error rather than understanding.

## How It Works

1. **Failures are recorded** in `.rigour/state.json` when operations fail
2. **Categories are auto-detected** from error patterns
3. **After N consecutive failures** in the same category, the gate FAILS
4. **The fix packet** instructs the agent to STOP and read official documentation

## Configuration

```yaml
gates:
  retry_loop_breaker:
    enabled: true           # Enable/disable the gate
    max_retries: 3          # Fail after this many consecutive failures
    auto_classify: true     # Auto-detect failure category from error message
    doc_sources:            # Custom documentation URLs per category
      deployment: "https://vercel.com/docs"
      module_resolution: "https://nodejs.org/api/esm.html"
```

## Failure Categories

The gate auto-classifies errors into these categories:

| Category | Error Patterns | Default Doc Hint |
|----------|----------------|------------------|
| `module_resolution` | `ERR_REQUIRE_ESM`, `Cannot find module`, `MODULE_NOT_FOUND` | Node.js ESM docs |
| `deployment` | `FUNCTION_INVOCATION_FAILED`, `Build Failed`, `deploy.*fail` | Platform docs |
| `runtime_error` | `TypeError`, `SyntaxError`, `ReferenceError`, `compilation.*error` | Language docs |
| `network` | `Connection refused`, `ECONNREFUSED`, `timeout`, `ETIMEDOUT` | Network config |
| `permissions` | `Permission denied`, `EACCES`, `EPERM` | File permissions |
| `resources` | `ENOMEM`, `heap out of memory`, `OOM` | Resource limits |
| `general` | Any unclassified error | Relevant docs |

## Example Output

When the gate detects a retry loop:

```json
{
  "id": "retry_loop_breaker",
  "title": "Retry Loop Detected: deployment",
  "details": "Operation 'deployment' has failed 4 times consecutively. Last error: FUNCTION_INVOCATION_FAILED",
  "hint": "STOP RETRYING. You are in a loop. Consult the official documentation: https://vercel.com/docs. Extract the canonical solution pattern and apply it."
}
```

## MCP Integration

For agents using the MCP server, two tools are available:

### `rigour_record_failure`

Record a failure when an operation fails:

```json
{
  "name": "rigour_record_failure",
  "arguments": {
    "cwd": "/path/to/project",
    "error_message": "FUNCTION_INVOCATION_FAILED: Cannot find module",
    "category": "deployment"  // Optional - auto-detected if omitted
  }
}
```

### `rigour_clear_failure`

Clear failure history after successful resolution:

```json
{
  "name": "rigour_clear_failure", 
  "arguments": {
    "cwd": "/path/to/project",
    "category": "deployment"  // Use "all" to clear everything
  }
}
```

## State File

Failure history is stored in `.rigour/state.json`:

```json
{
  "failureHistory": {
    "deployment": {
      "category": "deployment",
      "count": 4,
      "lastError": "FUNCTION_INVOCATION_FAILED",
      "lastTimestamp": "2026-01-06T11:00:00Z"
    }
  }
}
```

> [!TIP]
> Add `.rigour/state.json` to `.gitignore` to prevent committing local failure state.

## Custom Documentation Sources

Override the default documentation hints for specific categories:

```yaml
gates:
  retry_loop_breaker:
    doc_sources:
      deployment: "https://docs.mycompany.com/deployment"
      runtime_error: "https://docs.mycompany.com/debugging"
      module_resolution: "https://docs.mycompany.com/dependencies"
```

## Philosophy

> After N consecutive failures on the same operation category, **STOP GUESSING** and consult official documentation.

This gate enforces the principle that when you're stuck, the answer is almost always in the documentation‚Äînot in more guessing.


---

## MCP/MCP-SERVER

# MCP Server

Connect Rigour directly to your AI agents (Cursor, Claude Code, etc.) to enforce quality standards in real-time.

---

## ‚ö° Quick Start

```bash
npx -y @rigour-labs/mcp
```

---

## üîå Integration Recipes

### ü§ñ Claude Code (CLI)
```bash
claude mcp add rigour -- npx -y @rigour-labs/mcp
```

### üñ±Ô∏è Cursor
1. Go to **Settings > Features > MCP**.
2. **+ Add New MCP Server**:
   - **Name**: `Rigour`
   - **Type**: `command`
   - **Command**: `npx -y @rigour-labs/mcp`

### üõ†Ô∏è Cline / Roo Code
Add this to your `cline_mcp_settings.json`:
```json
{
  "mcpServers": {
    "rigour": {
      "command": "npx",
      "args": ["-y", "@rigour-labs/mcp"]
    }
  }
}
```

---

## üõ†Ô∏è Essential Tools

Once connected, your AI agent will automatically use these tools:

| Tool | Purpose |
|:---|:---|
| `rigour_check` | Runs all quality gates on your code. |
| `rigour_run` | **Interceptable** command execution (e.g., tests, deploys). |
| `rigour_find_patterns` | Semantic search for codebase patterns. |
| `rigour_remember` | Persist architectural decisions in memory. |
| `rigour_recall` | Retrieve stored engineering context. |
| `rigour_get_fix_packet` | Get precise refactoring instructions on failure. |

---

## üèóÔ∏è How it Works: The Local Bridge

Even if your AI agent (like Cursor or Claude Code) is communicating with a model in the cloud, the **Governance Interception** happens entirely on your local machine.

### The Handshake Architecture

```mermaid
graph TD
    subgraph "Your Machine (Local)"
        A["AI Agent (Cursor/Claude)"] -- runs --> B["Rigour MCP Server<br/>(local process)"]
        B -- writes events --> C[".rigour/events.jsonl<br/>(Shared File System)"]
        D["Rigour Studio<br/>(Local Dashboard)"] -- watches --> C
        D -- writes decision --> C
        B -- reads decision --> C
    end
    
    subgraph "Cloud"
        E["AI Model (Claude/GPT-4)"] -- instructs --> A
    end
```

### The Synchronization Flow:
1. **Local Spawn**: When you add the Rigour MCP to your IDE, the IDE launches the server as a **local process** on your machine.
2. **Shared State**: Both the MCP server and the Studio UI point to the same `.rigour` folder in your project root.
3. **Air-Gapped Arbitration**: 
   - The MCP server writes an "interception requested" log.
   - The Studio UI (via EventStream) detects this change instantly and pauses the agent.
   - Your local decision (Approve/Reject) is written back to the log.
   - The local MCP server sees your decision and returns the result to the AI agent.

### üõ°Ô∏è Zero-Telemetry & Local Trust

Rigour is intentionally **local-first**. Unlike other governance tools that require cloud connectivity, Rigour's interception layer is built on a "Local Bridge" architecture:

- **Local Storage**: All interception logs and human decisions are stored only in your `.rigour/` folder.
- **Air-Gapped Sync**: The synchronization between your AI agent and the Governance Studio happens entirely on your machine via the local filesystem.
- **Zero Push**: We never push your source code, your command history, or your arbitration decisions to any external server.

*This ensures that your project's engineering standards and command executions remain 100% private and under your total control.*

## üåê Web vs. Desktop: The Governance Moat

| Feature | Desktop (Cursor / Claude Desktop) | Web (Claude.ai / ChatGPT) |
|:---|:---|:---|
| **File Access** | ‚úÖ Native (direct disk read/write) | ‚ùå Sandboxed (no local disk access) |
| **Trust Model** | üõ°Ô∏è **Local Honest** (100% Private) | ‚òÅÔ∏è Cloud-Mediated (requires tunnel) |
| **Setup** | `npx @rigour-labs/mcp` | Hosted Connector + Tunnel |

### Why doesn't the Web App see my local files?
For security, your browser cannot run shell commands or read your hard drive. To bridge Rigour to a web app, you would need to use a **Secure Tunnel** (like `ngrok`) to expose a local SSE server. 

> [!IMPORTANT]
> To maintain the **Local Honest** moat, we recommend using Rigour with **Desktop AI Agents**. If you must use the web version, look into our [Remote MCP Server](/mcp/remote-mcp-server) for the E2E-encrypted connectivity.

---

## üí° Pro Tip
Always keep the [Rigour Studio](/concepts/governance-studio) open on a second monitor while working with MCP agents. It provides a visual audit trail of everything the agent is doing.


---

## MCP/MEMORY-PERSISTENCE

# Memory Persistence Tools

Rigour's MCP server includes tools for context memory persistence - solving the common problem of AI agents losing context and not following user instructions across sessions.

## The Problem

AI coding assistants often:
- Forget user preferences between sessions
- Lose track of project-specific conventions
- Repeat mistakes they were told to avoid
- Fail to follow critical instructions

## The Solution

Rigour provides three MCP tools for persistent memory:

### `rigour_remember`

Store instructions that persist across sessions:

```json
{
  "name": "rigour_remember",
  "arguments": {
    "cwd": "/path/to/project",
    "key": "coding_style",
    "value": "Always use TypeScript with strict mode. Prefer async/await over callbacks."
  }
}
```

### `rigour_recall`

Retrieve stored instructions at the start of each session:

```json
{
  "name": "rigour_recall",
  "arguments": {
    "cwd": "/path/to/project"
  }
}
```

This returns all stored memories. Pass a `key` to retrieve a specific memory.

### `rigour_forget`

Remove a stored memory:

```json
{
  "name": "rigour_forget",
  "arguments": {
    "cwd": "/path/to/project",
    "key": "deprecated_instruction"
  }
}
```

## Storage Location

Memories are stored in `.rigour/memory.json` within your project directory. This file is automatically gitignored when you run `rigour init`.

## Best Practices

1. **Start sessions with recall**: Always call `rigour_recall` at the start of a new session
2. **Use meaningful keys**: `user_preferences`, `coding_conventions`, `critical_warnings`
3. **Keep values concise**: Store actionable instructions, not verbose explanations
4. **Clean up**: Use `rigour_forget` to remove outdated instructions

## Example Workflow

```
User: "Remember that I prefer functional programming patterns"

Agent: *calls rigour_remember with key="coding_style"*

--- New session ---

Agent: *calls rigour_recall*
Agent: "I see you prefer functional programming patterns. I'll use that approach."
```


---

## MCP/REMOTE-MCP-SERVER

# Remote MCP Server

> [!NOTE]
> The Remote MCP Server is designed for **web-based agents** and cloud-hosted platforms. For local desktop agents like Cursor or Claude Code, use the [stdio-based MCP Server](/mcp/mcp-server) instead.

## Overview

The Remote MCP Server ([rigour-mcp](https://github.com/rigour-labs/rigour-mcp)) exposes Rigour's quality gates via HTTP using the Model Context Protocol's SSE (Server-Sent Events) transport. This enables web-based agent environments that cannot use stdio-based communication to benefit from Rigour's quality gates.

**Official Production Server**: `https://mcp.rigour.run/`

> [!TIP]
> Rigour provides a **free, public MCP server** at `https://mcp.rigour.run/` ‚Äî no authentication required, no setup needed, always available. Perfect for testing and development.

## When to Use

| Scenario | Use Remote MCP | Use Stdio MCP |
|----------|----------------|---------------|
| Web-based AI agents | ‚úÖ | |
| Cloud-hosted agent platforms | ‚úÖ | |
| Multi-tenant agent systems | ‚úÖ | |
| Browser-based tools | ‚úÖ | |
| Local desktop agents (Cursor, Claude) | | ‚úÖ |
| Single-user development | | ‚úÖ |
| Direct CLI integration | | ‚úÖ |

## Quick Start

### Using the Public Server

The fastest way to get started is using Rigour's public server:

```bash
# Health check
curl https://mcp.rigour.run/api/health

# Connect via SSE
# GET https://mcp.rigour.run/api/mcp/sse?sessionId=123
```

### Self-Hosting

For production deployments with authentication or custom configurations:

```bash
# Clone and deploy
git clone https://github.com/rigour-labs/rigour-mcp
cd rigour-mcp

# Deploy to Vercel (recommended)
vercel
```

## Authentication

Authentication is **optional** and controlled via the `RIGOUR_MCP_TOKEN` environment variable.

### Open Mode (No Authentication)

```bash
# No RIGOUR_MCP_TOKEN set - server accepts all requests
npm run dev
```

> [!WARNING]
> Only use open mode for private deployments or internal tools. For public-facing servers, always enable authentication.

### Bearer Token Authentication

```bash
# Generate a secure token
openssl rand -hex 32

# Set environment variable
export RIGOUR_MCP_TOKEN="your-generated-token-here"

# Start server
npm run dev
```

Clients must include the token in requests:

```bash
curl -X POST https://your-server.vercel.app/api/mcp/messages?sessionId=123 \
  -H "Authorization: Bearer your-generated-token-here" \
  -H "Content-Type: application/json" \
  -d '{ ... }'
```

## Client Integration

### Web-Based Agents (TypeScript)

```typescript
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

const transport = new SSEClientTransport(
  new URL("https://mcp.rigour.run/api/mcp/sse?sessionId=unique-id")
);

const client = new Client({
  name: "my-web-agent",
  version: "1.0.0"
}, {
  capabilities: {}
});

await client.connect(transport);

// Call Rigour tools
const result = await client.callTool({
  name: "rigour_status",
  arguments: {
    cwd: "/path/to/project"
  }
});
```

## Available Tools

The remote server exposes the same tools as the stdio version:

| Tool | Description |
|------|-------------|
| `rigour_check` | Run full quality gate audit |
| `rigour_explain` | Get human-readable failure explanations |
| `rigour_status` | Quick PASS/FAIL check (JSON) |
| `rigour_get_fix_packet` | Get prioritized fix instructions |
| `rigour_list_gates` | List active quality gates |
| `rigour_get_config` | Get project configuration |
| `rigour_record_failure` | Record a failure for retry loop detection |
| `rigour_clear_failure` | Clear failure history after resolution |

See [MCP Server](/mcp/mcp-server) for detailed tool documentation.

## Environment Variables

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `PORT` | No | `3000` | Server port |
| `RIGOUR_MCP_TOKEN` | No | ‚Äî | Bearer token for authentication |

## Architecture

| Component | Technology |
|-----------|------------|
| **Framework** | Next.js (App Router) |
| **Transport** | Standard SSE + HTTP POST |
| **Protocol** | MCP v2024-11-05+ |
| **Deployment** | Vercel (Native) |

## Troubleshooting

### "Unauthorized" Error

Ensure your `Authorization` header matches the `RIGOUR_MCP_TOKEN` set on the server:

```bash
curl -X POST https://your-server.vercel.app/api/mcp/messages?sessionId=123 \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json"
```

### Timeout Errors

Serverless platforms have execution limits (e.g., Vercel: 60s). For long-running checks:

1. Optimize your quality gates configuration
2. Deploy to a platform with longer timeouts (Cloud Run, Fly.io)
3. Split large checks into smaller batches

### "rigour.yml not found"

The remote server requires a `rigour.yml` file in the project directory:

1. Initialize the project: `rigour init`
2. Ensure the `cwd` path is absolute and correct
3. Verify the server has filesystem access to the project

## Security Best Practices

1. **Always use HTTPS** in production
2. **Set `RIGOUR_MCP_TOKEN`** for public deployments
3. **Rotate tokens** periodically (monthly recommended)
4. **Use environment variables** ‚Äî never commit tokens to git
5. **Monitor access logs** for suspicious activity
6. **Rate limit** using platform features (Vercel/Cloudflare)

## Next Steps

- [Configure Quality Gates](/concepts/ast-gates)
- [Understand Fix Packets](/concepts/fix-packet)
- [Explore CLI Commands](/cli/commands)


---

## REFERENCE/CONFIGURATION

# Configuration Reference

Complete reference for `rigour.yml` configuration.

## Full Example

```yaml
# rigour.yml
version: 1

# Project meta
preset: api
paradigm: oop

# Performance & UI commands
commands:
  format: "npm run format"
  test: "npm test"

# Quality Gates
gates:
  max_file_lines: 500
  forbid_todos: true
  
  # AST Gates
  ast:
    complexity: 10
    max_params: 5
    
  # Safety Rails
  safety:
    max_files_changed_per_cycle: 10
    protected_paths:
      - ".github/**"
      - "docs/**"
      - "rigour.yml"
```

## Options Reference

### `version`

**Type:** `number`  
**Default:** `1`

Schema version for the config file.

---

### `gates.safety.protected_paths`

**Type:** `string[]`  
**Default:** `[".github/**", "docs/**", "rigour.yml"]`

Glob patterns for files that cannot be modified by the agent.

---

### `gates.safety.max_files_changed_per_cycle`

**Type:** `number`  
**Default:** `10`

Maximum number of files that can be changed in a single agent turn before Rigour aborts.

---

### `preset`

**Type:** `string`  
**Options:** `api`, `ui`, `infra`, `data`

Project-level preset that defines default gate thresholds.

---

---

### `architecture.boundaries`

**Type:** `array`  
**Description:** Enforce strict layering rules by forbidding specific import paths based on the file's location.

```yaml
gates:
  architecture:
    boundaries:
      - from: "src/api/**"
        to: "src/ui/**"
        mode: "deny"
      - from: "packages/core/**"
        to: "packages/cli/**"
        mode: "deny"
```

| Property | Description |
|:---|:---|
| `from` | Glob pattern representing the source file(s). |
| `to` | Glob pattern representing the forbidden import/path. |
| `mode` | Currently only `deny` is supported for strict isolation. |

**How it works**: Rigour's AST engine scans your import declarations. If a file matching the `from` pattern attempts to import a module matching the `to` pattern, the audit fails. This is essential for preventing circular dependencies and leaky abstractions in large monorepos.

---

### `gates.dependencies.forbid`

**Type:** `string[]`  
**Description:** Prevent specific third-party packages from being added to your project.

```yaml
gates:
  dependencies:
    forbid:
      - "lodash" # Use native ES6 instead
      - "axios"  # Use fetch
```

---

### `gates.ast`

**Type:** `object`
**Description:** Configures syntax-aware gates for code quality.

| Option | Default | Description |
|:---|:---:|:---|
| `complexity` | `10` | **SME Logic**: Cognitive complexity limit (cyclomatic + nesting depth). |
| `max_methods` | `10` | Max methods allowed per class. |
| `max_params` | `5` | Max arguments allowed per function signature. |
| `max_function_lines` | `50` | Max lines of code per function body. |

---

### `gates.coverage`
**Description**: Enables the "Quality Handshake" between static structural risks and dynamic runtime coverage.

| Option | Type | Description |
|:---|:---:|:---|
| `risk_adjusted` | `boolean` | If true, complex files (complexity > 10) require >80% coverage. |

---

## Universal Language Support
Rigour provides built-in, syntax-aware AST analysis for:
**TypeScript, JavaScript, Go, Rust, Python, Java, C#, C, C++, PHP, Swift, and Kotlin.**

---

## Custom Command Gates (Agnosticism)

The most powerful feature of Rigour is its ability to wrap **any** third-party tool as a first-class quality gate. Use this to extend Rigour beyond its built-in SME logic:

```yaml
commands:
  # Wrap security scanners
  security: "trivy fs ."
  
  # Wrap custom domain rules
  custom: "./scripts/my-logic.sh"
```

### The "Universal Handshake"
When you define a command:
1.  **Execution**: Rigour runs the command in your project's `cwd`.
2.  **Validation**: If the command exits with **Code 0**, it `PASSES`. If it exits with any other code, it `FAILS`.
3.  **Feedback**: The `stderr` or `stdout` from your tool is automatically captured and placed into the **Fix Packet**.
4.  **Refinement**: AI agents will read your tool's raw output and attempt to fix the code to make the gate pass.

This allows you to bring your existing enterprise toolchain into the Rigour supervisor loop.


---

